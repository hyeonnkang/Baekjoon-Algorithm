# 문제 주소 https://www.acmicpc.net/problem/6588

# 풀이

짝수가 입력되었을 때, 이를 소수인 홀수의 합으로 표현하라는 문제였다. 간단한 문제로 보았지만 생각보다 많이 헤맸다.

1. 숫자의 범위 만큼 소수인지 합성수인지 판별해서 배열에 저장
2. 사용자로부터 정수 n를 입력받는다.
   - 정수가 0이면 프로그램을 종료한다.
   - 정수가 0이 아닐 경우
     - 홀수 a = 3, b = n - a로 초기화한다.
     - a와 b가 소수인지 확인한다.
     - 소수일 경우 화면에 결과 출력하고 사용자로부터 새로운 정수 n을 입력
     - 소수가 아닐 경우 a += 2, b = n - a 를 한 후 다시 (2)(3) 과정을 반복한다.
     - 연산 중 a > b가 될 경우 "Goldbach's conjecture is wrong"

입력될 때 마다 소수를 구해 시간 초과가 나고,

```cpp
cin.tie(NULL);
ios_base::sync_with_stdio(0);
```

없이 cin을 통해 입력을 받았을 때, 시간초과가 발생하였다. 위 코드는 이번 문제를 풀면서 처음 사용해본 코드이다.

```cpp
cin.tie(NULL);
```

cin과 cout은 스트림으로 묶여 있는데, 한 스트림이 다른 스트림에서 작업을 수행하기 전에 자동으로 버퍼를 비워준다. 이 코드를 사용하면 이 cin과 count의 묶음을 풀어준다.

```cpp
cout << "first";
cin >> k;
```

이 코드에서 first 가 먼저 출력되지 않고 k를 먼저 입력받을 수 있다는 뜻이다.

```cpp
ios_base::sync_with_stdio(0);
```

ios_base::sync_with_stdio 는 c의 stdio와 c++의 iostream 을 동기화 시켜주는데, 이 때 딜레이가 발생한다. 따라서 이 코드를 작성해줌으로써 동기화를 비활성화시켜주는 것이다.
c++만의 독립적인 버퍼가 생성되어 c의 버퍼와 병행하여 사용할 수 없게 되지만, 사용하는 버퍼의 수가 줄어들어 속도가 빨라진다.
단점으로는 멀티 쓰레드 환경에서 출력 순서를 보장할 수 없게 된다. cin과 c의 scanf, gets, getchar 등 사용 불가, cout과 c의 printf, puts, putchar 을 함께 사용하면 안된다.
